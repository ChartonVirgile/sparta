NOTE on making changes:  when commenting out a line, add "// EVENTUALLY DELETE FOR VTS (AKS)"


CHANGES-------------------------------------------------------------------------------------------

stats.cpp:
  new_time revised in compute_tpcpu()

grid.h:
added dt_desired to ChildCell class
  added time to ChildCell class                  (this is the cell time)
  added dt_global to Grid class                  (located here instead of update.h for restart)
  added global time (time_global) to Grid class  (located here instead of update.h for restart)
  added get_particle_time function (constructed from global time and cell desired dt)
  added variable_adaptive_time boolean

grid.cpp:
  added cell dt_desired and time (cell) to restarts (size_restart(), pack_restart(), unpack_restart())
  added grid dt_global and time_global to write_restart() and read_restart()
  initialized time_global to zero in Grid constructor
  add global time increment at top of timestep loop in Update::run()
  added get_particle_time function (constructed from global time and cell desired dt)
  set cell time to be time_global in add_child_cell

particle.h:
  added particle time to OnePart class
  added particle time to OnePartRestart class
  modified add_particle function to include particle_time in argument list

particle_kokkos.h
  overloaded add_particle_kokkos function to include particle_time in argument list

particle.cpp:
  added particle time copy to pack_restart() functions
  modified add_particle function to include particle_time in argument list


* switched to overloaded add_particle() with particle_time
  create_particles.cpp
  collide_vss.cpp
  fix_emit_surf.cpp
  fix_emit_face_file.cpp
  fix_emit_face.cpp
  read_particles.cpp
  read_restart.cpp

  surf_react_prob.cpp
  surf_react_global.cpp
    where add_particle appears, the new particle time was copied from the existing "i" particle

  surf_react_adsorb.cpp
    where add_particle appears with "i" particle data, the new particle time was copied from the existing "i" particle.
    However, there are some add_particle calls that I don't understand (where pcell is passed in through the argument list
    but is not set previously).

  Also, in the fix_emit*.cpp files, dt_global was set in the init functions but also reset prior to use in other functions
  in these files since dt_global will change as the simulation proceeds.

read_restart.cpp
  began modifying create_child_cells()

input.[h,cpp]
  added parsing of variable "timestep_va", the variable-adaptive starting timestep

update.cpp
  added logic to skip particle move if not sufficiently lagging the global time

collide.cpp
  added variable_adaptive_time logic to collisions_one(), collisions_group(), collisions_one_ambipolar(), and collisions_group_ambipolar()
  added dtc (collision time-step) to argument list of attempt_collision() and find_nn() variants.

added new fix framework to compute global dt:  fix_dt_global.[h,cpp]




QUESTIONS-----------------------------------------------------------------------------------------

check into reset_timestep(), compute_dt()

what is the impact of variable timestepping on computes and fixes?

In update.cpp does particle ever move less than full dt?????? ------> ANSWER: at end of loop advecting
  all particles, particles[i].dtremain = 0.  Therefore, the particle time does not need to be adjusted
  by the time remaining in the move interval as in ds2v.f90.

In ds2v.f90, why does the move stop (with particle time adjusted accordingly) if the time remaining
in the move is less than 0.1*characteristic_cell_time (or in SPARTA language, 0.1*dt_desired for the cell).






TODO-----------------------------------------------------------------------------------------------

finish logic added to ReadRestart::create_child_cells for cell dt (put dt in add_child_cell() argument list?)
  Could add optional argument for cell dt when calling create_child_cells for restart case.   obviously would
  need to compute it otherwise, e.g., during grid construction (read_grid.cpp).  But what about AMR? adopt global
  time step as cell dt until mean collision time and mean traversal time are available? or use some fraction of
  the parent cell dt?  (THESE ISSUES MIGHT BE IMPACTED WTIH NEW USE OF CUSTOM TIME DATA STORAGE)

need to make sure that cell dt_desired is set before particles are created initially

how should particle times be set in the add_particle() calls in surf_react_adsorb.cpp (where
pcell is also passed in but not set)?  Look at dtremain as well.  Note that the AddParticle class
does not have time data.

how is dt_global set and updated?

check on update->ntimestep and where that is set.

look for setting particle_time in collide_vss_kokkos and see if variable_adaptive_time boolean use is needed.

try building and running with -DSPARTA_KOKKOS_EXACT (added to SPARTA_INC)

check locations where grid->dt_global is used and see if modifications are needed for use_cell_dt = true.

check FixDt::update_custom for emitting boolean.  Figure out how to generalize this. (check this logic in beforeCustomAttributes
directory)

check for update_custom call consistency
  -search for add_particle:  surf_react* functions call add_particle but not update_custom.  I noticed that add_particle
   is called in perform_collision in collide_vss.cpp, but in this case, you don't want the standard update_custom stuff
   called as defined in fix_dt.cpp.  In this case, you probably want to copy the time from one particle to the new one.
   We probably just need to add update_custom calls to surf_react* code.

in collide.cpp, make sure custom particle time logic is ok.  Details:  in collide.cpp, perform_task is called
and particle_time for a new particle is adjusted there, but then in ambipolar code in collide.cpp, particle_time
is adjusted again after the add_particle() calls with no arguments.

compare use_global_dt option with custom particle/cell times and with particle/cell times in the grid/particle classes to
make sure we get the same answer. (don't want to break that functionality in the custom time code).  Do this after the KOKKOS
custom time stuff is implemented.


BUILDING AND RUNNING WITH KOKKOS------------------------------------------------------

on mac:
% cd src
% make yes-kokkos
% make kokkos_mpi_only
% pushd ~/Codes/sparta_examples_AKS/collide
% ~/Codes/sparta/src/spa_kokkos_mpi_only -k on t 1 -sf kk < in.collide

on vortex:
% module load gcc/8.3.1
% module load cuda/11.2.0
% export CUDA_MANAGED_FORCE_DEVICE_ALLOC=1
% export CUDA_LAUNCH_BLOCKING=1
% cd Codes/sparta/src
% cp ~/Makefile.summit_kokkos MAKE
% make yes-kokkos
% make summit_kokkos
% lalloc 1
% pushd ../examples/collide
% jsrun -M "-gpu -disable_gdr" -l gpu-gpu -d packed -n 1 -a 1 -c 1 ~/Codes/sparta/src/spa_summit_kokkos -in in.collide -k on g 1 -sf kk





